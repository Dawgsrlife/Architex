#!/usr/bin/env python3
"""
BRUTAL VERIFICATION TEST
========================
Tests each phase of the Architex pipeline INDEPENDENTLY.
If any phase fails, we know exactly where.

This is NOT a trust-based test. This proves things work.

Run with:
    cd backend && source venv/bin/activate
    python tests/verify_full_flow.py

Requires:
    MONGODB_URI
    GOOGLE_GEMINI_API_KEY (optional - can skip Gemini test)
    GITHUB_TOKEN (optional - can skip GitHub test)
"""

import asyncio
import os
import sys
import shutil
import subprocess
import json
from pathlib import Path
from datetime import datetime
from typing import Dict, Any, Optional, Tuple

# Add parent to path
sys.path.insert(0, str(Path(__file__).parent.parent))

from dotenv import load_dotenv
load_dotenv()

# ============================================================================
# PHASE 1: FILESYSTEM VERIFICATION
# Can we create workspace and write files?
# ============================================================================

def test_phase1_filesystem() -> Tuple[bool, str, Optional[Path]]:
    """
    Test: Create workspace, write files, verify tree.
    
    Success criteria:
    - Directory created at /tmp/architex/test_verify_<timestamp>/
    - Can write nested files
    - Can count files
    - Tree structure is correct
    """
    print("\n" + "="*60)
    print("PHASE 1: FILESYSTEM VERIFICATION")
    print("="*60)
    
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    workspace_path = Path(f"/tmp/architex/test_verify_{timestamp}")
    
    try:
        # Create workspace
        workspace_path.mkdir(parents=True, exist_ok=True)
        print(f"  ✓ Created workspace: {workspace_path}")
        
        # Write test files (simulating what Cline would do)
        test_files = {
            "README.md": "# Test Project\n\nGenerated by Architex",
            "package.json": json.dumps({"name": "test", "version": "1.0.0"}, indent=2),
            "src/index.js": "console.log('hello');",
            "src/utils/helper.js": "export const add = (a, b) => a + b;",
            "src/components/App.jsx": "export const App = () => <div>Hello</div>;",
            ".gitignore": "node_modules/\n.env",
            "Dockerfile": "FROM node:18\nWORKDIR /app\nCOPY . .\nCMD [\"node\", \"src/index.js\"]"
        }
        
        for path, content in test_files.items():
            full_path = workspace_path / path
            full_path.parent.mkdir(parents=True, exist_ok=True)
            full_path.write_text(content, encoding="utf-8")
        
        print(f"  ✓ Wrote {len(test_files)} files")
        
        # Count files
        all_files = list(workspace_path.rglob("*"))
        actual_files = [f for f in all_files if f.is_file()]
        print(f"  ✓ Verified {len(actual_files)} files exist")
        
        # Print tree
        print("\n  File tree:")
        for f in sorted(actual_files):
            rel = f.relative_to(workspace_path)
            size = f.stat().st_size
            print(f"    {rel} ({size} bytes)")
        
        return True, "Filesystem operations work correctly", workspace_path
        
    except Exception as e:
        return False, f"Filesystem error: {e}", None


# ============================================================================
# PHASE 2: GIT VERIFICATION
# Can we init repo, commit, verify commit hash?
# ============================================================================

def test_phase2_git(workspace_path: Path) -> Tuple[bool, str]:
    """
    Test: Initialize git, commit, verify history.
    
    Success criteria:
    - git init succeeds
    - git add . succeeds
    - git commit succeeds
    - Can read commit hash
    - Commit contains expected files
    """
    print("\n" + "="*60)
    print("PHASE 2: GIT VERIFICATION")
    print("="*60)
    
    try:
        # Init
        result = subprocess.run(
            ["git", "init", "-b", "main"],
            cwd=workspace_path,
            capture_output=True,
            text=True
        )
        if result.returncode != 0:
            return False, f"git init failed: {result.stderr}"
        print("  ✓ git init")
        
        # Config
        subprocess.run(
            ["git", "config", "user.name", "Architex Test"],
            cwd=workspace_path,
            check=True,
            capture_output=True
        )
        subprocess.run(
            ["git", "config", "user.email", "test@architex.dev"],
            cwd=workspace_path,
            check=True,
            capture_output=True
        )
        print("  ✓ git config")
        
        # Add
        result = subprocess.run(
            ["git", "add", "."],
            cwd=workspace_path,
            capture_output=True,
            text=True
        )
        if result.returncode != 0:
            return False, f"git add failed: {result.stderr}"
        print("  ✓ git add .")
        
        # Commit
        result = subprocess.run(
            ["git", "commit", "-m", "Architex: Generated architecture"],
            cwd=workspace_path,
            capture_output=True,
            text=True
        )
        if result.returncode != 0:
            return False, f"git commit failed: {result.stderr}"
        print("  ✓ git commit")
        
        # Get commit hash
        result = subprocess.run(
            ["git", "rev-parse", "HEAD"],
            cwd=workspace_path,
            capture_output=True,
            text=True
        )
        if result.returncode != 0:
            return False, f"git rev-parse failed: {result.stderr}"
        
        commit_hash = result.stdout.strip()
        print(f"  ✓ Commit hash: {commit_hash[:8]}")
        
        # Verify commit content
        result = subprocess.run(
            ["git", "ls-tree", "-r", "HEAD", "--name-only"],
            cwd=workspace_path,
            capture_output=True,
            text=True
        )
        files_in_commit = result.stdout.strip().split("\n")
        print(f"  ✓ Commit contains {len(files_in_commit)} files")
        
        return True, f"Git operations work. Commit: {commit_hash[:8]}"
        
    except Exception as e:
        return False, f"Git error: {e}"


# ============================================================================
# PHASE 3: LLM API VERIFICATION  
# Can we call the LLM and get structured tool responses?
# ============================================================================

async def test_phase3_llm() -> Tuple[bool, str, Optional[Dict]]:
    """
    Test: Call LLM (Groq preferred) with a minimal prompt, verify tool-format response.
    
    Success criteria:
    - API call succeeds
    - Response contains valid JSON
    - Response has expected tool format
    """
    print("\n" + "="*60)
    print("PHASE 3: LLM API VERIFICATION")
    print("="*60)
    
    groq_key = os.getenv("GROQ_API_KEY")
    gemini_key = os.getenv("GOOGLE_GEMINI_API_KEY")
    
    if not groq_key and not gemini_key:
        return False, "No LLM API key set (GROQ_API_KEY or GOOGLE_GEMINI_API_KEY) - SKIPPED", None
    
    try:
        import re
        
        # Prefer Groq
        if groq_key:
            from groq import Groq
            client = Groq(api_key=groq_key)
            
            test_prompt = """You are a coding agent. Respond ONLY with valid JSON, no other text.

Your task: Write a single hello world file.

Use this exact format:
{
    "tool": "write_file",
    "params": {
        "path": "hello.py",
        "content": "print('hello world')"
    }
}"""
            
            print("  → Calling Groq (llama-3.3-70b-versatile)...")
            response = client.chat.completions.create(
                model="llama-3.3-70b-versatile",
                messages=[{"role": "user", "content": test_prompt}],
                max_tokens=200
            )
            text = response.choices[0].message.content
            provider = "Groq"
        else:
            import google.generativeai as genai
            genai.configure(api_key=gemini_key)
            model = genai.GenerativeModel('gemini-2.0-flash')
            
            test_prompt = """You are a coding agent. Respond ONLY with valid JSON, no other text.

Your task: Write a single hello world file.

Use this exact format:
{
    "tool": "write_file",
    "params": {
        "path": "hello.py",
        "content": "print('hello world')"
    }
}"""
            
            print("  → Calling Gemini...")
            response = model.generate_content(test_prompt)
            text = response.text
            provider = "Gemini"
        
        print(f"  ← Got response ({len(text)} chars)")
        
        # Try to parse as JSON
        json_match = re.search(r'\{.*\}', text, re.DOTALL)
        if not json_match:
            return False, f"No JSON found in response: {text[:200]}", None
        
        tool_call = json.loads(json_match.group(0))
        
        if "tool" not in tool_call:
            return False, f"No 'tool' key in response: {tool_call}", None
        
        print(f"  ✓ Valid tool call: {tool_call['tool']}")
        print(f"  ✓ Params: {json.dumps(tool_call.get('params', {}), indent=4)[:200]}")
        
        return True, f"{provider} API works and returns structured tool calls", tool_call
        
    except Exception as e:
        error_str = str(e)
        if "429" in error_str or "quota" in error_str.lower():
            return False, "API quota exceeded - try again later", None
        return False, f"LLM error: {e}", None


# ============================================================================
# PHASE 4: CLINE AGENT SIMULATION
# Can the agentic loop write multiple files?
# ============================================================================

async def test_phase4_agent_loop() -> Tuple[bool, str, Optional[Path]]:
    """
    Test: Run a simplified agent loop that writes files.
    
    This tests the ACTUAL cline_service.run_agent logic.
    
    Success criteria:
    - Agent writes ≥3 files
    - Agent calls task_complete OR reaches reasonable file count
    - Files have non-empty content
    """
    print("\n" + "="*60)
    print("PHASE 4: AGENT LOOP VERIFICATION")
    print("="*60)
    
    api_key = os.getenv("GOOGLE_GEMINI_API_KEY")
    if not api_key:
        return False, "GOOGLE_GEMINI_API_KEY not set - SKIPPED", None
    
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    workspace_path = Path(f"/tmp/architex/test_agent_{timestamp}")
    workspace_path.mkdir(parents=True, exist_ok=True)
    
    try:
        # Minimal architecture spec
        architecture_spec = {
            "name": "Hello World CLI",
            "description": "A simple Python CLI that prints hello world",
            "nodes": [
                {"id": "1", "type": "file", "label": "main.py", "data": {"tech": "Python"}},
                {"id": "2", "type": "file", "label": "utils.py", "data": {"tech": "Python"}}
            ],
            "edges": [
                {"source": "1", "target": "2", "label": "imports"}
            ]
        }
        
        # Import the actual cline service
        from services.cline import cline_service
        
        print(f"  → Starting agent in {workspace_path}")
        print(f"  → Architecture: {architecture_spec['name']}")
        
        success = await cline_service.run_agent(
            job_id="test_verify",
            workspace_path=workspace_path,
            architecture_spec=architecture_spec
        )
        
        # Count files
        all_files = list(workspace_path.rglob("*"))
        actual_files = [f for f in all_files if f.is_file()]
        
        if len(actual_files) == 0:
            return False, "Agent wrote 0 files", workspace_path
        
        print(f"\n  Files created:")
        total_bytes = 0
        for f in sorted(actual_files):
            rel = f.relative_to(workspace_path)
            size = f.stat().st_size
            total_bytes += size
            print(f"    {rel} ({size} bytes)")
        
        print(f"\n  Total: {len(actual_files)} files, {total_bytes} bytes")
        
        if success:
            return True, f"Agent completed successfully with {len(actual_files)} files", workspace_path
        else:
            if len(actual_files) >= 2:
                return True, f"Agent wrote {len(actual_files)} files (didn't call task_complete but produced output)", workspace_path
            return False, f"Agent failed (wrote only {len(actual_files)} files)", workspace_path
        
    except Exception as e:
        error_str = str(e)
        if "429" in error_str or "quota" in error_str.lower():
            return False, "Gemini quota exceeded - try again later", workspace_path
        return False, f"Agent error: {e}", workspace_path


# ============================================================================
# PHASE 5: GITHUB API VERIFICATION
# Can we create a repo and push? (optional)
# ============================================================================

async def test_phase5_github(workspace_path: Path) -> Tuple[bool, str]:
    """
    Test: Create a repo, add remote, push.
    
    Success criteria:
    - Repo created (or already exists)
    - Push succeeds
    - Can verify files exist on GitHub
    """
    print("\n" + "="*60)
    print("PHASE 5: GITHUB API VERIFICATION")
    print("="*60)
    
    github_token = os.getenv("GITHUB_TOKEN")
    if not github_token:
        return False, "GITHUB_TOKEN not set - SKIPPED (set it to test GitHub)"
    
    try:
        import httpx
        
        timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
        repo_name = f"architex-test-verify-{timestamp}"
        
        # Create repo
        async with httpx.AsyncClient(timeout=30.0) as client:
            resp = await client.post(
                "https://api.github.com/user/repos",
                headers={
                    "Authorization": f"Bearer {github_token}",
                    "Accept": "application/vnd.github.v3+json",
                },
                json={
                    "name": repo_name,
                    "private": False,
                    "auto_init": False,
                    "description": "Architex verification test (safe to delete)"
                }
            )
            
            if resp.status_code == 201:
                repo_url = resp.json().get("html_url")
                print(f"  ✓ Created repo: {repo_url}")
            elif resp.status_code == 422:
                # Already exists
                user_resp = await client.get(
                    "https://api.github.com/user",
                    headers={"Authorization": f"Bearer {github_token}"}
                )
                username = user_resp.json().get("login")
                repo_url = f"https://github.com/{username}/{repo_name}"
                print(f"  ✓ Repo already exists: {repo_url}")
            else:
                return False, f"GitHub API error {resp.status_code}: {resp.text[:200]}"
        
        # Init git if not already
        if not (workspace_path / ".git").exists():
            subprocess.run(["git", "init", "-b", "main"], cwd=workspace_path, check=True, capture_output=True)
            subprocess.run(["git", "config", "user.name", "Architex"], cwd=workspace_path, check=True, capture_output=True)
            subprocess.run(["git", "config", "user.email", "test@architex.dev"], cwd=workspace_path, check=True, capture_output=True)
            subprocess.run(["git", "add", "."], cwd=workspace_path, check=True, capture_output=True)
            subprocess.run(["git", "commit", "-m", "Test commit"], cwd=workspace_path, check=True, capture_output=True)
        
        # Add remote and push
        auth_url = repo_url.replace("https://github.com/", f"https://{github_token}@github.com/")
        
        subprocess.run(["git", "remote", "remove", "origin"], cwd=workspace_path, capture_output=True)
        subprocess.run(["git", "remote", "add", "origin", auth_url], cwd=workspace_path, check=True, capture_output=True)
        
        result = subprocess.run(
            ["git", "push", "-u", "origin", "main", "--force"],
            cwd=workspace_path,
            capture_output=True,
            text=True
        )
        
        if result.returncode != 0:
            return False, f"Push failed: {result.stderr}"
        
        print(f"  ✓ Pushed to {repo_url}")
        print(f"\n  ⚠️  CLEANUP: Delete this repo manually if you want:")
        print(f"      {repo_url}/settings (scroll to bottom → Delete)")
        
        return True, f"GitHub operations work. Repo: {repo_url}"
        
    except Exception as e:
        return False, f"GitHub error: {e}"


# ============================================================================
# PHASE 6: MONGODB VERIFICATION
# Can we create project, job, update status?
# ============================================================================

async def test_phase6_mongodb() -> Tuple[bool, str]:
    """
    Test: Create project, create job, verify DB operations.
    """
    print("\n" + "="*60)
    print("PHASE 6: MONGODB VERIFICATION")
    print("="*60)
    
    mongodb_uri = os.getenv("MONGODB_URI")
    if not mongodb_uri:
        return False, "MONGODB_URI not set"
    
    try:
        from database.mongo import init_mongo, close_mongo, get_db
        from repos import projects_repo, jobs_repo
        import uuid
        
        await init_mongo()
        db = get_db()
        
        user_id = f"test_verify_{uuid.uuid4().hex[:8]}"
        project_id = None
        job_id = None
        
        try:
            # Create project
            project_doc = await projects_repo.create_project(user_id, "Verification Test Project")
            project_id = project_doc["projectId"]
            print(f"  ✓ Created project: {project_id[:8]}...")
            
            # Create job (note: prompt is inside architecture_spec)
            job_doc = await jobs_repo.create_job(
                userId=user_id,
                projectId=project_id,
                architecture_spec={"prompt": "Test prompt", "test": True}
            )
            job_id = job_doc["jobId"]
            print(f"  ✓ Created job: {job_id[:8]}...")
            
            # Update status
            await jobs_repo.update_job_status(user_id, job_id, "running")
            print("  ✓ Updated status to running")
            
            # Append logs (logs is a list of dicts with timestamp and message)
            await jobs_repo.append_job_logs(user_id, job_id, [{"timestamp": "2026-01-17T00:00:00", "message": "Test log entry"}])
            print("  ✓ Appended log")
            
            # Update to completed
            await jobs_repo.update_job_status(
                user_id, job_id, "completed",
                result={"test": True}
            )
            print("  ✓ Updated status to completed")
            
            # Verify
            job = await jobs_repo.get_job(user_id, job_id)
            if job.get("status") != "completed":
                return False, f"Status mismatch: expected completed, got {job.get('status')}"
            print("  ✓ Verified final status")
            
            return True, "MongoDB operations work correctly"
            
        finally:
            # Cleanup
            if project_id:
                await db.projects.delete_one({"projectId": project_id})
            if job_id:
                await db.jobs.delete_one({"jobId": job_id})
            await close_mongo()
            print("  ✓ Cleaned up test data")
            
    except Exception as e:
        return False, f"MongoDB error: {e}"


# ============================================================================
# MAIN: Run all phases
# ============================================================================

async def main():
    print("\n" + "="*70)
    print("ARCHITEX FULL FLOW VERIFICATION")
    print("="*70)
    print(f"Timestamp: {datetime.now().isoformat()}")
    print("="*70)
    
    results = {}
    workspace_for_git = None
    workspace_for_github = None
    
    # Phase 1: Filesystem
    success, msg, workspace = test_phase1_filesystem()
    results["1_filesystem"] = (success, msg)
    if success:
        workspace_for_git = workspace
    
    # Phase 2: Git (using Phase 1 workspace)
    if workspace_for_git:
        success, msg = test_phase2_git(workspace_for_git)
        results["2_git"] = (success, msg)
    else:
        results["2_git"] = (False, "Skipped - Phase 1 failed")
    
    # Phase 3: LLM API (Groq preferred, Gemini fallback)
    success, msg, tool_call = await test_phase3_llm()
    results["3_llm"] = (success, msg)
    
    # Phase 4: Agent Loop (creates new workspace)
    success, msg, workspace = await test_phase4_agent_loop()
    results["4_agent"] = (success, msg)
    if success and workspace:
        workspace_for_github = workspace
    
    # Phase 5: GitHub (optional, uses Phase 4 workspace)
    if workspace_for_github:
        success, msg = await test_phase5_github(workspace_for_github)
        results["5_github"] = (success, msg)
    else:
        # Use Phase 1 workspace as fallback
        if workspace_for_git:
            success, msg = await test_phase5_github(workspace_for_git)
            results["5_github"] = (success, msg)
        else:
            results["5_github"] = (False, "Skipped - no workspace available")
    
    # Phase 6: MongoDB
    success, msg = await test_phase6_mongodb()
    results["6_mongodb"] = (success, msg)
    
    # Cleanup workspaces
    print("\n" + "="*60)
    print("CLEANUP")
    print("="*60)
    
    for wp in [workspace_for_git, workspace_for_github]:
        if wp and wp.exists():
            shutil.rmtree(wp, ignore_errors=True)
            print(f"  ✓ Cleaned {wp}")
    
    # Summary
    print("\n" + "="*70)
    print("VERIFICATION SUMMARY")
    print("="*70)
    
    all_passed = True
    critical_failed = []
    
    for phase, (success, msg) in sorted(results.items()):
        status = "✓ PASS" if success else "✗ FAIL"
        if "SKIPPED" in msg:
            status = "○ SKIP"
        print(f"  {phase}: {status}")
        print(f"    → {msg}")
        
        if not success and "SKIPPED" not in msg:
            all_passed = False
            critical_failed.append(phase)
    
    print("\n" + "="*70)
    
    if all_passed:
        print("✓ ALL PHASES PASSED")
        print("  The core pipeline is functional.")
    else:
        print("✗ FAILURES DETECTED")
        print(f"  Failed phases: {', '.join(critical_failed)}")
        print("\n  Action items:")
        for phase in critical_failed:
            if "gemini" in phase:
                print("    - Fix Gemini: Check API key, quota, model name")
            elif "agent" in phase:
                print("    - Fix Agent: Debug cline_service.run_agent()")
            elif "github" in phase:
                print("    - Fix GitHub: Check GITHUB_TOKEN permissions")
            elif "mongodb" in phase:
                print("    - Fix MongoDB: Check connection string")
    
    print("="*70)
    
    return 0 if all_passed else 1


if __name__ == "__main__":
    exit_code = asyncio.run(main())
    sys.exit(exit_code)
